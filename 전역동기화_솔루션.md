# 🎯 Casino-Club F2P 전역 동기화 솔루션

## ✅ 진행 체크리스트 (2025-09-01)
- [x] `/api/users/balance` 권위 확정 및 전역 동기화 반영(useGlobalSync)
- [x] 로그인 전 403 소음 제거(무토큰 가드) 및 400/401 UX 정규화(unifiedApi, useAuth)
- [x] UI 셀렉터-우선 구조 확립(constants/gameStatsKeys.ts, hooks/useGameStats.ts)
- [x] /api/games/stats/me 래핑({success, stats})/루트 본문 동시 지원 문서화(unwrap 예시)
- [x] FE E2E: stats API 스모크 및 가드 모드 준비(games_stats_api_smoke.spec)
- [x] /api/games/stats/me 포맷 최종 단일화(백엔드) 또는 셀렉터 범위 최종 확정(FE)
  - 결정: 백엔드 단일 포맷 고정 → `{ success: true, stats: {...} }`
  - FE는 `unwrapStats()`로 하위호환 유지하되, 다음 릴리스에 루트 본문 fallback 제거 예고(문서화 완료)
 [x] 분산 훅 스윕 완료 → 대체 경로 연결 후 제거
  - [x] 레거시 훅 파일(useDashboard.ts/useBalanceSync.ts) 소스에서 제거
  - [x] 클린 빌드 후 산출물 정리(.next)
    - [x] 문서 갱신(정리 완료 시 체크)
- [ ] E2E_REQUIRE_STATS_PARITY=1 전환(게이트: /api/games/stats/me 200 x2 + UI=API 3회 연속 PASS)
  - [x] 컨테이너 Playwright(기본 프로파일) 연속 3회 그린 기록(무 parity 플래그)
  - [x] frontend/components/TokenBalanceWidget.tsx 호출처 마이그레이션
  - [ ] parity 게이트 검증 실행 및 체크 반영
- [ ] E2E_REQUIRE_STATS_PARITY=1 전환 후 그린 1회 추가 + deep 1회 선택 실행
- [ ] STRICT_STATS_PARITY=1 승격
- [ ] api docs/20250808.md에 “클린 빌드/산출물 정리 완료” 및 변경 요약 반영(필요 시 OpenAPI 재수출)
  - [x] frontend/components/games/NeonSlotGame.tsx
  - [x] frontend/components/games/GachaSystem.tsx
      - useDashboard 호출처
  - [x] frontend/components/HomeDashboard.tsx
  - [x] useBalanceSync에 @deprecated 주석 추가
  - [x] useDashboard에 @deprecated 주석 추가
  - [x] 호출처 대체(useGlobalSync.syncBalance / useGameStats)
  - [x] 레거시 훅 파일(useDashboard.ts) 소스에서 제거
  - [x] 1회 빌드/스모크 통과 후 산출물 정리(.next) 완료
    - [x] 삭제 변경은 main에 직접 반영됨(별도 PR 병합 불필요), 본 문서 갱신 완료
    
### E2E_REQUIRE_STATS_PARITY 게이트 검증 플로우(컨테이너)
- 검증 기준: (a) `/api/games/stats/me` 200 연속 2회 (b) UI 합계=testid(`games-stats-total` 등) 기준 API와 일치 3회 연속
- 진행 현황:
  - [x] `/api/games/stats/me` 200 확인 #1
  - [ ] `/api/games/stats/me` 200 확인 #2
  - [ ] UI=API 파리티 PASS #1
  - [ ] UI=API 파리티 PASS #2
  - [ ] UI=API 파리티 PASS #3
- 후속: 게이트 통과 후 `E2E_REQUIRE_STATS_PARITY=1`로 1회 그린 + deep 1회(선택) → `STRICT_STATS_PARITY=1` 승격

### 실행 커맨드(Windows PowerShell)
```powershell
# 1) 베이스 프로파일에서 게이트 검증(임시 parity ON)
$env:E2E_REQUIRE_STATS_PARITY = "1"; .\cc-manage.ps1 e2e:playwright; Remove-Item Env:E2E_REQUIRE_STATS_PARITY -ErrorAction SilentlyContinue

# 2) parity ON 상태로 1회 추가 그린 + deep(선택) 1회
$env:E2E_REQUIRE_STATS_PARITY = "1"; .\cc-manage.ps1 e2e:playwright; Remove-Item Env:E2E_REQUIRE_STATS_PARITY -ErrorAction SilentlyContinue
$env:E2E_REQUIRE_STATS_PARITY = "1"; .\cc-manage.ps1 e2e:playwright:deep; Remove-Item Env:E2E_REQUIRE_STATS_PARITY -ErrorAction SilentlyContinue

# 3) 안정화 후 STRICT 승격
$env:STRICT_STATS_PARITY = "1"; .\cc-manage.ps1 e2e:playwright; Remove-Item Env:STRICT_STATS_PARITY -ErrorAction SilentlyContinue
```

### 분산 훅 스윕 리스트(대체 경로/제거 체크)
- 유지: useGlobalSync(권위 동기화), useGlobalUser(스토어 셀렉터), useRealtimeSync(WS 반영)
- 대체 연결 후 제거 대상:
  - useBalanceSync → useGlobalSync.syncBalance 사용으로 대체 [x] 제거 준비 [x] 호출처 대체 [x] 삭제(산출물 정리 완료)
  - 진행: 호출처 대체 완료(4/4). 클린 빌드로 .next 참조 제거 완료.
  - useDashboard → useGameStats/useGlobalStore 조합으로 대체 [x] 대체 [x] 삭제(소스 기준)

### 변경 메모(2025-09-01 추가)
- HomeDashboard의 useDashboard 의존 제거 확인(전역 셀렉터 + 개별 엔드포인트 사용).
- 레거시 훅 파일 useDashboard.ts 삭제(소스). .next 산출물에 남은 참조는 클린 빌드 시 제거.
- E2E 컨테이너 테스트(무 parity) 연속 그린: 3/3 확보. parity 게이트 검증 대기.

### 검증(누적)
- pytest: 백엔드 GameStats 관련 테스트 그린 유지(세션 격리, flush-only 정책).
- Playwright(무 parity): 컨테이너 3회 연속 그린 확인.
- Alembic heads: 단일 head 유지(수동 확인 필요 시 docker 내에서 재검증).

### 다음 단계(단기)
- [ ] E2E_REQUIRE_STATS_PARITY=1 게이트 검증(200 x2, UI=API x3) 실행
- [ ] E2E_REQUIRE_STATS_PARITY=1로 1회 추가 그린 + deep 1회(선택) 실행 후 STRICT 승격 검토
- [ ] api docs/20250808.md에 변경 요약/검증/다음 단계 반영 및 필요 시 OpenAPI 재수출
### FE Deprecation 고지(다음 릴리스 노트 반영)
- unwrapStats 루트 본문 fallback 제거 예정 → 백엔드 `{success, stats}` 래핑만 지원. 하위호환 필요 시 이번 릴리스 내 마이그레이션 완료 필요.
- 훅 @deprecated: useBalanceSync, useDashboard — 전역 동기화(useGlobalSync)와 스토어 셀렉터로 마이그레이션 권장.

### Playwright 파리티 승격 절차(컨테이너)
1) 로컬/CI에서 `E2E_REQUIRE_STATS_PARITY=1` 없이 3회 연속 실행 기록 → UI=API 불일치 0회 확인
2) `/api/games/stats/me` 200을 2회 연속 확인
3) 이후 `E2E_REQUIRE_STATS_PARITY=1`로 그린 1회 + deep(선택) 1회 추가
4) 운영 승격 시 `STRICT_STATS_PARITY=1` 설정
  - useEvents → useRealtimeSync(필요 이벤트만)로 대체 [ ] 범위 축소 [ ] 삭제
  - useRecentActions → 통합 셀렉터/서버 페이지네이션 확정 후 [ ] 대체 [ ] 삭제
  - useProfileUpdate → useGlobalSync.refresh + 단일 서비스 호출로 [ ] 대체 [ ] 삭제
  - 기타 게임별 임시 훅(useGameConfig 등) → 상수/스토어 셀렉터로 [ ] 대체 [ ] 삭제

메모: 제거 전 “호출처 대체 → 1회 빌드/스모크 → PR” 순으로 진행. 동일 목적 파일 중복 금지.

## 📋 현재 상황 분석

### 문제점 요약
1. **분산된 데이터 소스**
   - 백엔드: `/api/auth/me`, `/api/users/balance`, `/api/games/stats/me` 등
   - 프론트: GlobalStore, useAuth, useBalanceSync 등 여러 상태 관리
   - 각 화면이 다른 API를 호출하여 데이터 불일치

2. **하드코딩된 로직**
   - 게임 컴포넌트들이 로컬에서 잔액 계산
   - 프로필/대시보드/게임이 각자 다른 방식으로 데이터 표시
   - WebSocket과 REST API 간 동기화 부재

3. **권위 소스 불명확**
   - gold balance의 진짜 소스가 불분명
   - 여러 엔드포인트가 같은 데이터를 다르게 반환

## ✅ 즉시 적용 가능한 해결책

### Step 1: 단일 권위 소스 확립
```typescript
// 백엔드 권위 소스 정의
const AUTHORITY_ENDPOINTS = {
  USER_PROFILE: '/api/auth/me',        // 사용자 전체 정보
  USER_BALANCE: '/api/users/balance',  // 잔액 권위
  GAME_STATS: '/api/games/stats/me'    // 게임 통계
};
```

### Step 2: GlobalStore 중앙화
```typescript
// 모든 데이터를 GlobalStore로 일원화
interface GlobalState {
  // 권위 데이터
  profile: {
    id: string;
    nickname: string;
    level: number;
    xp: number;
  };
  balance: {
    gold: number;  // 단일 통화
    gems?: number; // 옵션
  };
  gameStats: {
    slots: { plays: number; wins: number; };
    rps: { plays: number; wins: number; };
    crash: { plays: number; wins: number; };
    gacha: { pulls: number; rares: number; };
  };
  // 동기화 상태
  lastSyncAt: number;
  syncErrors: string[];
}
```

### Step 3: 동기화 훅 통합
```typescript
// useGlobalSync.ts - 모든 동기화를 담당하는 단일 훅
export function useGlobalSync() {
  const { state, dispatch } = useGlobalStore();
  
  // NOTE: /api/games/stats/me 응답 호환 처리
  // - 현재 백엔드는 { success: boolean, stats: {...} } 래핑 또는 바로 {...} 본문을 반환할 수 있음
  // - 아래 헬퍼는 두 형태를 모두 안전하게 지원
  const unwrapStats = (res: any) => {
    // axios/fetch 응답 어디에 있든 stats 오브젝트만 추출
    const d = res?.data ?? res;
    return d?.stats ?? d ?? {};
  };
  
  // 전체 데이터 동기화
  const syncAll = async () => {
    try {
      // 병렬로 모든 권위 소스 호출
      const [profileRes, balanceRes, statsRes] = await Promise.all([
        api.get('/api/auth/me'),
        api.get('/api/users/balance'),
        api.get('/api/games/stats/me')
      ]);
      
      // GlobalStore에 일괄 업데이트
      dispatch({
        type: 'SYNC_ALL',
        payload: {
          profile: profileRes.data,
          balance: { gold: balanceRes.data?.cyber_token_balance },
          gameStats: unwrapStats(statsRes),
          lastSyncAt: Date.now()
        }
      });
    } catch (error) {
      dispatch({ type: 'SYNC_ERROR', error: error.message });
    }
  };
  
  // 게임 플레이 후 동기화
  const syncAfterGame = async () => {
    // 잔액과 통계만 업데이트
    const [balanceRes, statsRes] = await Promise.all([
      api.get('/api/users/balance'),
      api.get('/api/games/stats/me')
    ]);
    
    dispatch({
      type: 'UPDATE_GAME_DATA',
      payload: {
        balance: { gold: balanceRes.data?.cyber_token_balance },
        gameStats: unwrapStats(statsRes)
      }
    });
  };
  
  return { syncAll, syncAfterGame, lastSync: state.lastSyncAt };
}
```

### Step 4: 컴포넌트 표준화
```typescript
// 모든 컴포넌트가 GlobalStore만 사용
export function ProfileScreen() {
  const { profile, balance } = useGlobalProfile();
  const { syncAll } = useGlobalSync();
  
  useEffect(() => {
    syncAll(); // 마운트 시 동기화
  }, []);
  
  return (
    <div>
      <h1>{profile.nickname}</h1>
      <p>Gold: {balance.gold}</p>
  {/* 간단 합계 예시: 총 플레이/승 */}
  {/* 전역 스토어 gameStats 기준 */}
  {/* const { state } = useGlobalStore(); const rps = state.gameStats?.rps || {}; */}
  {/* 
    셀렉터 패턴(간단형) 예시:
    const firstNumber = (...vals: any[]) => vals.find(v => typeof v === 'number') ?? 0;
    const rpsPlays = firstNumber(rps?.total_plays, rps?.totalGames, rps?.plays);
    const rpsWins  = firstNumber(rps?.total_wins,  rps?.wins);
  */}
  {/* <p data-testid="stats-total-rps">RPS: {rpsPlays} 플레이 / {rpsWins} 승</p> */}
    </div>
  );
}
```

### Step 5: 게임 컴포넌트 수정
```typescript
// 게임 플레이 후 반드시 동기화
export function RockPaperScissorsGame() {
  const { balance } = useGlobalProfile();
  const { syncAfterGame } = useGlobalSync();
  
  const playGame = async (choice: string) => {
    // 게임 플레이 API 호출
    const result = await api.post('/api/games/rps/play', {
      choice,
      bet_amount: betAmount
    });
    
    // 로컬 계산 금지! 서버 응답만 표시
    showResult(result.data);
    
    // 전역 상태 동기화
    await syncAfterGame();
  };
}
```

## 🚀 구현 우선순위

### Phase 1: 백엔드 정리 (1일) — 진행중
1. `/api/users/balance`를 gold balance의 유일한 권위로 확정
2. 모든 게임 API가 일관된 응답 형식 반환
3. WebSocket 이벤트에 balance 변경사항 포함

/api/users/balance 권위 확정: 완료
프론트 전역 동기화/로그인 후 병합이 balance 응답을 1순위로 사용.
게임 API 응답 형식 일관화: 부분 완료
RPS 요청/응답 스키마 정렬 완료. /games/stats/me는 {success, stats} 래핑 혼재 → 프론트에서 unwrapStats로 호환 처리(문서 반영).
WS에 balance 반영: 부분 완료
reward_granted/purchase_update/profile_update 수신 시 즉시 반영+재하이드레이트. 전 이벤트에 balance 포함 보장은 추후 점검 항목.
Phase 2 — GlobalStore 통합

### Phase 2: GlobalStore 통합 (2일) — 진행중
1. GlobalStore에 모든 상태 통합
2. useGlobalSync 훅 구현
3. 기존 분산된 훅들 제거

GlobalStore 통합: 완료
profile/balances/gameStats 전역 상태로 일원화, 주요 화면 적용.
useGlobalSync 훅: 완료
syncAll/syncAfterGame/주기 동기화 동작, 무토큰 시 호출 skip 가드 추가(403 소음 제거).
분산 훅 제거: 진행 중
핵심 동기화 훅은 통합 완료. 일부 레거시/기능별 훅(useEvents/useDashboard 등)은 유지 중(안전 제거 대상 선별 필요).



### Phase 3: 컴포넌트 마이그레이션 (3일) — 진행중
1. ProfileScreen → GlobalStore 사용
2. HomeDashboard → GlobalStore 사용
3. 모든 게임 컴포넌트 → GlobalStore 사용
4. Shop/Inventory → GlobalStore 사용
5. Profile/Home에 게임 합계 카드 노출(총 플레이/승 등 요약)

### Phase 4: 실시간 동기화 (2일) — 대기
1. WebSocket 이벤트 리스너 통합
2. 자동 재동기화 로직 구현
3. 오프라인 대응 로직

## 📊 검증 체크리스트

### 동기화 테스트
- [x] 로그인 직후 모든 화면에 같은 gold 표시
- [x] 게임 플레이 후 모든 화면에 즉시 반영
- [ ] 프로필 수정 시 모든 화면에 반영
- [x] 새로고침 후에도 데이터 일관성 유지

### 게임별 테스트
- [x] 슬롯머신: 베팅→결과→잔액 동기화
- [x] 가위바위보: 베팅→결과→잔액 동기화
- [x] 크래시: 베팅→캐시아웃→잔액 동기화
- [x] 가챠: 구매→결과→잔액 동기화

### UI=API 파리티
- [ ] UI 게임 합계가 /api/games/stats/me 응답과 일치(플레이/승/넷이익 등 핵심 필드)
  - 팁: 합계 노드에 `data-testid="games-stats-total"`(또는 게임별 `stats-total-<game>`)을 부여해 E2E에서 안정적으로 단언

### 엣지 케이스
- [ ] 동시 게임 플레이 시 정합성(동시 베팅 → syncAfterGame 병렬 호출 가드)
- [ ] 네트워크 오류 시 복구(재시도/백오프, 마지막 성공 스냅샷 복원)
- [ ] 토큰 만료 시 재인증 후 동기화(401 시 토큰 갱신 후 syncAll)

## 🔧 즉시 시작 가능한 작업

### 1. 백엔드 권위 소스 확정
```python
# backend/app/routers/users.py
@router.get("/balance")
async def get_user_balance(current_user: User = Depends(get_current_user)):
    """Gold balance의 유일한 권위 소스"""
    return {
        "cyber_token_balance": current_user.cyber_tokens,
        "timestamp": datetime.utcnow(),
        "user_id": current_user.id
    }
```

### 2. 프론트엔드 GlobalSync 구현
```typescript
// frontend/hooks/useGlobalSync.ts
export function useGlobalSync() {
  // 위 코드 구현
}
```

### 3. 첫 번째 화면 마이그레이션
```typescript
// ProfileScreen을 첫 번째로 전환
// 성공하면 다른 화면들도 동일하게 적용
```

이렇게 하면 모든 화면에서 동일한 데이터를 보게 되고, 전역 동기화가 완성됩니다.
